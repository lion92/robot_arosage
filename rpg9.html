<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Survie Zombie sur la Plage 3D</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Orbitron', monospace;
      cursor: crosshair;
      background: #000;
    }
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #0ff;
      background: linear-gradient(135deg, rgba(0,0,0,0.9), rgba(0,50,100,0.7));
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
      font-size: 14px;
      border: 2px solid rgba(0,255,255,0.3);
      box-shadow: 0 0 30px rgba(0,255,255,0.5), inset 0 0 20px rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
    }

    #stats {
      position: absolute;
      top: 10px;
      right: 10px;
      color: #fff;
      background: linear-gradient(135deg, rgba(139,0,0,0.9), rgba(255,0,0,0.6));
      padding: 15px;
      border-radius: 8px;
      z-index: 100;
      font-size: 16px;
      font-weight: bold;
      border: 2px solid rgba(255,0,0,0.5);
      box-shadow: 0 0 40px rgba(255,0,0,0.6), inset 0 0 20px rgba(0,0,0,0.5);
      backdrop-filter: blur(10px);
      text-shadow: 0 0 10px rgba(255,0,0,0.8);
    }

    #healthBar {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 30px;
      background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(50,0,0,0.8));
      border: 2px solid rgba(255,255,255,0.8);
      border-radius: 15px;
      z-index: 100;
      box-shadow: 0 0 30px rgba(255,0,0,0.8), inset 0 0 15px rgba(0,0,0,0.9);
    }

    #healthFill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ff6666, #ffaaaa);
      border-radius: 13px;
      transition: width 0.3s;
      width: 100%;
      box-shadow: 0 0 20px rgba(255,0,0,0.8), inset 0 0 10px rgba(255,255,255,0.3);
      animation: healthPulse 2s infinite;
    }

    @keyframes healthPulse {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.2); }
    }

    #waveAnnouncement {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff0000;
      background: radial-gradient(ellipse, rgba(0,0,0,0.95), rgba(139,0,0,0.8));
      padding: 30px 60px;
      border-radius: 10px;
      border: 3px solid #ff0000;
      font-size: 48px;
      font-weight: bold;
      display: none;
      z-index: 200;
      text-shadow: 0 0 20px rgba(255,0,0,1), 0 0 40px rgba(255,0,0,0.8);
      box-shadow: 0 0 100px rgba(255,0,0,0.8), inset 0 0 50px rgba(0,0,0,0.5);
      animation: waveGlow 0.5s infinite alternate;
    }

    @keyframes waveGlow {
      from { transform: translate(-50%, -50%) scale(1); }
      to { transform: translate(-50%, -50%) scale(1.05); }
    }

    canvas {
      display: block;
      filter: contrast(1.1) saturate(1.2);
    }
  </style>
</head>
<body>
<div id="info">
  ‚öîÔ∏è <b>SURVIE ZOMBIE</b><br>
  ‚¨ÜÔ∏è ZQSD/Fl√®ches : Se d√©placer<br>
  üñ±Ô∏è Clic gauche : Attaquer<br>
  ü¶ò Espace : Sauter<br>
  üèÉ Shift : Courir<br>
  üìπ C : Changer de vue<br>
  üé£ F : P√™cher (soigne 10 PV)<br>
  üí∞ E : Ramasser les objets<br>
  üíÄ Survivez aux vagues !
</div>

<div id="stats">
  üßü Zombies tu√©s: <span id="killCount">0</span><br>
  üåä Vague: <span id="waveNumber">1</span><br>
  ‚öîÔ∏è Restants: <span id="remainingZombies">0</span><br>
  üí∞ Pi√®ces: <span id="coins">0</span><br>
  üó°Ô∏è Arme: <span id="currentWeapon">√âp√©e</span><br>
  ‚öîÔ∏è D√©g√¢ts: <span id="attackPower">20</span><br>
  üõ°Ô∏è Armure: <span id="armor">0</span><br>
  üëü Vitesse: <span id="speedBonus">x1</span>
</div>

<div id="healthBar">
  <div id="healthFill"></div>
</div>

<div id="waveAnnouncement">
  VAGUE <span id="waveText">1</span> !
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
  // Configuration de la sc√®ne avec am√©lioration des graphismes
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({
    antialias: true,
    powerPreference: "high-performance",
    alpha: false
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  renderer.outputEncoding = THREE.sRGBEncoding;
  document.body.appendChild(renderer.domElement);

  // Brouillard atmosph√©rique am√©lior√©
  scene.fog = new THREE.FogExp2(0x001122, 0.008);

  // Lumi√®res am√©lior√©es
  const ambientLight = new THREE.AmbientLight(0x223344, 0.3);
  scene.add(ambientLight);

  const moonLight = new THREE.DirectionalLight(0x88aaff, 1.2);
  moonLight.position.set(50, 100, 50);
  moonLight.castShadow = true;
  moonLight.shadow.camera.left = -100;
  moonLight.shadow.camera.right = 100;
  moonLight.shadow.camera.top = 100;
  moonLight.shadow.camera.bottom = -100;
  moonLight.shadow.mapSize.width = 4096;
  moonLight.shadow.mapSize.height = 4096;
  moonLight.shadow.bias = -0.001;
  scene.add(moonLight);

  // Lumi√®re rouge d'ambiance pour effet horrifique
  const redLight = new THREE.PointLight(0xff0000, 0.3, 100);
  redLight.position.set(0, 20, 0);
  scene.add(redLight);

  // Ciel nocturne avec gradient
  const skyGeometry = new THREE.SphereGeometry(400, 64, 64);
  const skyMaterial = new THREE.ShaderMaterial({
    uniforms: {
      topColor: { value: new THREE.Color(0x000033) },
      bottomColor: { value: new THREE.Color(0x330000) },
      offset: { value: 33 },
      exponent: { value: 0.6 }
    },
    vertexShader: `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
    fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying vec3 vWorldPosition;
            void main() {
                float h = normalize(vWorldPosition + offset).y;
                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
            }
        `,
    side: THREE.BackSide
  });
  const sky = new THREE.Mesh(skyGeometry, skyMaterial);
  scene.add(sky);

  // Lune am√©lior√©e avec halo
  const moonGeometry = new THREE.SphereGeometry(10, 32, 32);
  const moonMaterial = new THREE.MeshLambertMaterial({
    color: 0xffffee,
    emissive: 0xffffaa,
    emissiveIntensity: 0.8
  });
  const moon = new THREE.Mesh(moonGeometry, moonMaterial);
  moon.position.set(50, 80, -100);
  scene.add(moon);

  // Halo de lune
  const moonGlow = new THREE.PointLight(0xffffaa, 2, 200);
  moonGlow.position.copy(moon.position);
  scene.add(moonGlow);

  // √âtoiles
  const starsGeometry = new THREE.BufferGeometry();
  const starsMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.7,
    transparent: true,
    opacity: 0.8,
    sizeAttenuation: false
  });
  const starsVertices = [];
  for (let i = 0; i < 10000; i++) {
    const x = (Math.random() - 0.5) * 800;
    const y = Math.random() * 200 + 50;
    const z = (Math.random() - 0.5) * 800;
    starsVertices.push(x, y, z);
  }
  starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
  const stars = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(stars);

  // Plage avec texture am√©lior√©e
  const beachGeometry = new THREE.PlaneGeometry(300, 300, 100, 100);
  const beachMaterial = new THREE.MeshStandardMaterial({
    color: 0x8b7355,
    roughness: 0.9,
    metalness: 0.1,
    normalScale: new THREE.Vector2(0.5, 0.5)
  });
  const beach = new THREE.Mesh(beachGeometry, beachMaterial);
  beach.rotation.x = -Math.PI / 2;
  beach.receiveShadow = true;

  const beachVertices = beachGeometry.attributes.position.array;
  for (let i = 0; i < beachVertices.length; i += 3) {
    beachVertices[i + 2] = Math.sin(beachVertices[i] * 0.1) * 0.5 + Math.random() * 0.2;
  }
  beachGeometry.attributes.position.needsUpdate = true;
  beachGeometry.computeVertexNormals();
  scene.add(beach);

  // Oc√©an avec shader am√©lior√©
  const oceanGeometry = new THREE.PlaneGeometry(500, 500, 150, 150);
  const oceanMaterial = new THREE.MeshPhongMaterial({
    color: 0x001133,
    transparent: true,
    opacity: 0.85,
    shininess: 200,
    specular: 0x111155,
    emissive: 0x000011,
    emissiveIntensity: 0.2
  });
  const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
  ocean.rotation.x = -Math.PI / 2;
  ocean.position.z = -100;
  ocean.position.y = -0.5;
  scene.add(ocean);

  // VARIABLES GLOBALES
  let playerHealth = 100;
  let killCount = 0;
  let currentWave = 1;
  let zombiesPerWave = 3;
  let zombies = [];
  let isAttacking = false;
  let attackCooldown = 0;
  const lootItems = [];
  let coins = 0;
  let attackPower = 20;
  let armor = 0;
  let speedBonus = 1;
  let currentWeapon = 'sword';
  let weaponRange = 5;
  let attackSpeed = 0.5;
  const weapons = {
    sword: { damage: 20, range: 5, speed: 0.5, color: 0xc0c0c0 },
    axe: { damage: 35, range: 4, speed: 0.8, color: 0x8B4513 },
    spear: { damage: 25, range: 8, speed: 0.6, color: 0xFFD700 },
    hammer: { damage: 50, range: 3, speed: 1.2, color: 0x696969 },
    katana: { damage: 30, range: 6, speed: 0.3, color: 0x4B0082 }
  };
  let isFishing = false;
  let fishingTimer = 0;
  const particles = [];
  const bloodParticles = [];
  const sparkParticles = [];
  const healParticles = [];

  // Syst√®me de particules am√©lior√©
  function createBloodEffect(position) {
    for (let i = 0; i < 30; i++) {
      const particleGeometry = new THREE.SphereGeometry(0.15 + Math.random() * 0.25, 6, 6);
      const particleMaterial = new THREE.MeshPhongMaterial({
        color: Math.random() > 0.5 ? 0x8B0000 : 0x660000,
        transparent: true,
        opacity: 0.9,
        emissive: 0x330000,
        emissiveIntensity: 0.3
      });
      const particle = new THREE.Mesh(particleGeometry, particleMaterial);
      particle.position.copy(position);
      particle.userData = {
        velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 0.8,
                Math.random() * 0.6 + 0.3,
                (Math.random() - 0.5) * 0.8
        ),
        life: 1.0
      };
      bloodParticles.push(particle);
      scene.add(particle);
    }
  }

  function createSparkEffect(position, color = 0xffff00) {
    for (let i = 0; i < 25; i++) {
      const sparkGeometry = new THREE.BoxGeometry(0.08, 0.5, 0.08);
      const sparkMaterial = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 1,
        emissive: color,
        emissiveIntensity: 1
      });
      const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
      spark.position.copy(position);
      spark.userData = {
        velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 1.5,
                Math.random() * 1.2,
                (Math.random() - 0.5) * 1.5
        ),
        life: 1.0,
        rotationSpeed: Math.random() * 0.8
      };
      sparkParticles.push(spark);
      scene.add(spark);
    }
  }

  function createHealEffect(position) {
    for (let i = 0; i < 15; i++) {
      const healGeometry = new THREE.OctahedronGeometry(0.25, 0);
      const healMaterial = new THREE.MeshPhongMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.9,
        emissive: 0x00ff00,
        emissiveIntensity: 0.8,
        specular: 0xffffff,
        shininess: 100
      });
      const healParticle = new THREE.Mesh(healGeometry, healMaterial);
      healParticle.position.copy(position);
      healParticle.position.y += Math.random() * 2;
      healParticle.userData = {
        velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                Math.random() * 0.4 + 0.2,
                (Math.random() - 0.5) * 0.2
        ),
        life: 1.0,
        startY: healParticle.position.y
      };
      healParticles.push(healParticle);
      scene.add(healParticle);
    }
  }

  const weaponTrail = [];
  const maxTrailLength = 15;

  function createWeaponTrail(position) {
    const trailGeometry = new THREE.BoxGeometry(0.15, 3, 0.08);
    const trailMaterial = new THREE.MeshBasicMaterial({
      color: currentWeapon === 'katana' ? 0x9400D3 :
              currentWeapon === 'axe' ? 0xFF4500 :
                      currentWeapon === 'hammer' ? 0x696969 :
                              currentWeapon === 'spear' ? 0xFFD700 : 0x00BFFF,
      transparent: true,
      opacity: 0.7,
      emissive: currentWeapon === 'katana' ? 0x9400D3 : 0x00BFFF,
      emissiveIntensity: 0.5
    });
    const trail = new THREE.Mesh(trailGeometry, trailMaterial);
    trail.position.copy(position);
    trail.rotation.copy(playerGroup.rotation);
    trail.userData = { life: 0.6 };
    weaponTrail.push(trail);
    scene.add(trail);

    if (weaponTrail.length > maxTrailLength) {
      const oldTrail = weaponTrail.shift();
      scene.remove(oldTrail);
    }
  }

  function createShockwave(position, size = 5) {
    const shockwaveGeometry = new THREE.RingGeometry(0.1, size, 64);
    const shockwaveMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.9,
      side: THREE.DoubleSide,
      emissive: 0xffffff,
      emissiveIntensity: 1
    });
    const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
    shockwave.position.copy(position);
    shockwave.rotation.x = -Math.PI / 2;

    let scale = 0.1;
    const expandInterval = setInterval(() => {
      scale += 0.4;
      shockwave.scale.set(scale, scale, 1);
      shockwave.material.opacity -= 0.06;
      if (shockwave.material.opacity <= 0) {
        clearInterval(expandInterval);
        scene.remove(shockwave);
      }
    }, 30);

    scene.add(shockwave);
  }

  const fireParticles = [];
  function createFireEffect(position) {
    for (let i = 0; i < 10; i++) {
      const fireGeometry = new THREE.TetrahedronGeometry(0.3, 0);
      const fireMaterial = new THREE.MeshPhongMaterial({
        color: Math.random() > 0.5 ? 0xff4500 : 0xffa500,
        transparent: true,
        opacity: 0.9,
        emissive: Math.random() > 0.5 ? 0xff4500 : 0xffa500,
        emissiveIntensity: 1
      });
      const fire = new THREE.Mesh(fireGeometry, fireMaterial);
      fire.position.copy(position);
      fire.userData = {
        velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 0.3,
                Math.random() * 0.5 + 0.3,
                (Math.random() - 0.5) * 0.3
        ),
        life: 0.7
      };
      fireParticles.push(fire);
      scene.add(fire);
    }
  }

  // PERSONNAGE GUERRIER AM√âLIOR√â
  const playerGroup = new THREE.Group();

  // Corps avec armure m√©tallique
  const bodyGeometry = new THREE.BoxGeometry(2, 3, 1);
  const bodyMaterial = new THREE.MeshStandardMaterial({
    color: 0x444455,
    metalness: 0.7,
    roughness: 0.3
  });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = 3;
  body.castShadow = true;
  playerGroup.add(body);

  // T√™te
  const headGeometry = new THREE.SphereGeometry(0.8, 16, 16);
  const headMaterial = new THREE.MeshStandardMaterial({
    color: 0xFFDBBD,
    roughness: 0.7
  });
  const head = new THREE.Mesh(headGeometry, headMaterial);
  head.position.y = 5.3;
  head.castShadow = true;
  playerGroup.add(head);

  // Casque m√©tallique brillant
  const helmetGeometry = new THREE.SphereGeometry(0.9, 16, 16);
  const helmetMaterial = new THREE.MeshStandardMaterial({
    color: 0x888899,
    metalness: 0.9,
    roughness: 0.1
  });
  const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
  helmet.position.y = 5.5;
  helmet.scale.y = 0.8;
  helmet.castShadow = true;
  playerGroup.add(helmet);

  // Yeux lumineux
  const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
  const eyeMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    emissive: 0x00ffff,
    emissiveIntensity: 0.5
  });
  const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
  leftEye.position.set(-0.3, 5.3, 0.7);
  playerGroup.add(leftEye);
  const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
  rightEye.position.set(0.3, 5.3, 0.7);
  playerGroup.add(rightEye);

  // Bras avec armure
  const armGeometry = new THREE.BoxGeometry(0.5, 2.5, 0.5);
  const armMaterial = new THREE.MeshStandardMaterial({
    color: 0x666677,
    metalness: 0.6,
    roughness: 0.4
  });
  const leftArm = new THREE.Mesh(armGeometry, armMaterial);
  leftArm.position.set(-1.5, 3, 0);
  leftArm.castShadow = true;
  playerGroup.add(leftArm);
  const rightArm = new THREE.Mesh(armGeometry, armMaterial);
  rightArm.position.set(1.5, 3, 0);
  rightArm.castShadow = true;
  playerGroup.add(rightArm);

  // √âP√âE LUMINEUSE
  const swordGroup = new THREE.Group();

  // Lame brillante
  const bladeGeometry = new THREE.BoxGeometry(0.2, 4, 0.5);
  const bladeMaterial = new THREE.MeshPhongMaterial({
    color: 0xaaccff,
    shininess: 200,
    specular: 0xffffff,
    emissive: 0x0066ff,
    emissiveIntensity: 0.2
  });
  const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
  blade.position.y = 2;
  blade.castShadow = true;
  swordGroup.add(blade);

  // Garde dor√©e
  const guardGeometry = new THREE.BoxGeometry(1.5, 0.2, 0.3);
  const guardMaterial = new THREE.MeshStandardMaterial({
    color: 0xffdd00,
    metalness: 0.9,
    roughness: 0.2
  });
  const guard = new THREE.Mesh(guardGeometry, guardMaterial);
  swordGroup.add(guard);

  // Poign√©e
  const handleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 8);
  const handleMaterial = new THREE.MeshStandardMaterial({
    color: 0x4a2c17,
    roughness: 0.8
  });
  const handle = new THREE.Mesh(handleGeometry, handleMaterial);
  handle.position.y = -0.8;
  swordGroup.add(handle);

  swordGroup.position.set(0.5, -1, 0.5);
  swordGroup.rotation.z = -Math.PI / 6;
  playerGroup.children[5].add(swordGroup);

  // Jambes
  const legGeometry = new THREE.BoxGeometry(0.7, 2.5, 0.7);
  const legMaterial = new THREE.MeshStandardMaterial({
    color: 0x333344,
    metalness: 0.5,
    roughness: 0.5
  });
  const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
  leftLeg.position.set(-0.5, 0.8, 0);
  leftLeg.castShadow = true;
  playerGroup.add(leftLeg);
  const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
  rightLeg.position.set(0.5, 0.8, 0);
  rightLeg.castShadow = true;
  playerGroup.add(rightLeg);

  // Bottes m√©talliques
  const footGeometry = new THREE.BoxGeometry(0.7, 0.3, 1.2);
  const footMaterial = new THREE.MeshStandardMaterial({
    color: 0x2a2a3a,
    metalness: 0.7,
    roughness: 0.3
  });
  const leftFoot = new THREE.Mesh(footGeometry, footMaterial);
  leftFoot.position.set(-0.5, -0.5, 0.2);
  leftFoot.castShadow = true;
  playerGroup.add(leftFoot);
  const rightFoot = new THREE.Mesh(footGeometry, footMaterial);
  rightFoot.position.set(0.5, -0.5, 0.2);
  rightFoot.castShadow = true;
  playerGroup.add(rightFoot);

  playerGroup.position.set(0, 0.5, 30);
  scene.add(playerGroup);

  // Lumi√®re du personnage
  const playerLight = new THREE.PointLight(0x0088ff, 0.5, 10);
  playerLight.position.y = 5;
  playerGroup.add(playerLight);

  // ZOMBIES AM√âLIOR√âS
  function createZombie(x, z) {
    const zombieGroup = new THREE.Group();

    // Corps zombie textur√©
    const zbodyGeometry = new THREE.BoxGeometry(1.8, 2.8, 0.9);
    const zbodyMaterial = new THREE.MeshStandardMaterial({
      color: 0x2d5016,
      roughness: 0.9,
      metalness: 0.1,
      emissive: 0x001100,
      emissiveIntensity: 0.1
    });
    const zbody = new THREE.Mesh(zbodyGeometry, zbodyMaterial);
    zbody.position.y = 3;
    zbody.castShadow = true;
    zombieGroup.add(zbody);

    // T√™te zombie
    const zheadGeometry = new THREE.SphereGeometry(0.7, 8, 8);
    const zheadMaterial = new THREE.MeshStandardMaterial({
      color: 0x4a6741,
      roughness: 1,
      emissive: 0x002200,
      emissiveIntensity: 0.05
    });
    const zhead = new THREE.Mesh(zheadGeometry, zheadMaterial);
    zhead.position.y = 5;
    zhead.castShadow = true;
    zombieGroup.add(zhead);

    // Yeux rouges lumineux
    const zeyeGeometry = new THREE.SphereGeometry(0.15, 6, 6);
    const zeyeMaterial = new THREE.MeshBasicMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 1
    });
    const zleftEye = new THREE.Mesh(zeyeGeometry, zeyeMaterial);
    zleftEye.position.set(-0.25, 5, 0.6);
    zombieGroup.add(zleftEye);
    const zrightEye = new THREE.Mesh(zeyeGeometry, zeyeMaterial);
    zrightEye.position.set(0.25, 5, 0.6);
    zombieGroup.add(zrightEye);

    // Lumi√®re rouge des yeux
    const eyeLight = new THREE.PointLight(0xff0000, 0.3, 5);
    eyeLight.position.set(0, 5, 0.6);
    zombieGroup.add(eyeLight);

    // Bras zombie
    const zarmGeometry = new THREE.BoxGeometry(0.4, 2.2, 0.4);
    const zarmMaterial = new THREE.MeshStandardMaterial({
      color: 0x4a6741,
      roughness: 0.9
    });
    const zleftArm = new THREE.Mesh(zarmGeometry, zarmMaterial);
    zleftArm.position.set(-1.3, 3, 0);
    zleftArm.rotation.x = -Math.PI / 6;
    zleftArm.castShadow = true;
    zombieGroup.add(zleftArm);
    const zrightArm = new THREE.Mesh(zarmGeometry, zarmMaterial);
    zrightArm.position.set(1.3, 3, 0);
    zrightArm.rotation.x = -Math.PI / 6;
    zrightArm.castShadow = true;
    zombieGroup.add(zrightArm);

    // Jambes zombie
    const zlegGeometry = new THREE.BoxGeometry(0.6, 2.3, 0.6);
    const zlegMaterial = new THREE.MeshStandardMaterial({
      color: 0x2d3319,
      roughness: 0.9
    });
    const zleftLeg = new THREE.Mesh(zlegGeometry, zlegMaterial);
    zleftLeg.position.set(-0.4, 0.8, 0);
    zleftLeg.castShadow = true;
    zombieGroup.add(zleftLeg);
    const zrightLeg = new THREE.Mesh(zlegGeometry, zlegMaterial);
    zrightLeg.position.set(0.4, 0.8, 0);
    zrightLeg.castShadow = true;
    zombieGroup.add(zrightLeg);

    zombieGroup.position.set(x, 0.5, z);

    zombieGroup.userData = {
      health: 30,
      speed: 0.1 + Math.random() * 0.05,
      attackCooldown: 0,
      walkAnimation: Math.random() * Math.PI * 2,
      isDead: false
    };

    return zombieGroup;
  }

  // Fonction de loot am√©lior√©e
  function createLootItem(position, type) {
    const lootGroup = new THREE.Group();

    if (type === 'coin') {
      const coinGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.1, 32);
      const coinMaterial = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        emissive: 0xffd700,
        emissiveIntensity: 0.5,
        metalness: 0.9,
        roughness: 0.1
      });
      const coin = new THREE.Mesh(coinGeometry, coinMaterial);
      coin.rotation.x = Math.PI / 2;
      coin.castShadow = true;
      lootGroup.add(coin);
      lootGroup.userData.type = 'coin';
      lootGroup.userData.value = 10;
    } else if (type === 'health') {
      const potionGeometry = new THREE.SphereGeometry(0.4, 16, 16);
      const potionMaterial = new THREE.MeshPhongMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 0.4,
        transparent: true,
        opacity: 0.85,
        shininess: 100,
        specular: 0xffffff
      });
      const potion = new THREE.Mesh(potionGeometry, potionMaterial);
      potion.castShadow = true;
      lootGroup.add(potion);
      lootGroup.userData.type = 'health';
      lootGroup.userData.value = 20;
    } else if (type === 'attack') {
      const swordGeometry = new THREE.BoxGeometry(0.1, 1, 0.3);
      const swordMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ffff,
        emissive: 0x00ffff,
        emissiveIntensity: 0.5,
        metalness: 0.8,
        roughness: 0.2
      });
      const miniSword = new THREE.Mesh(swordGeometry, swordMaterial);
      miniSword.rotation.z = Math.PI / 4;
      miniSword.castShadow = true;
      lootGroup.add(miniSword);
      lootGroup.userData.type = 'attack';
      lootGroup.userData.value = 5;
    } else if (type === 'armor') {
      const shieldGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.1);
      const shieldMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b4513,
        emissive: 0x8b4513,
        emissiveIntensity: 0.2,
        metalness: 0.7,
        roughness: 0.3
      });
      const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
      shield.castShadow = true;
      lootGroup.add(shield);
      lootGroup.userData.type = 'armor';
      lootGroup.userData.value = 1;
    } else if (type === 'speed') {
      const bootGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.5);
      const bootMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ff00,
        emissive: 0x00ff00,
        emissiveIntensity: 0.4,
        metalness: 0.5,
        roughness: 0.4
      });
      const boot = new THREE.Mesh(bootGeometry, bootMaterial);
      boot.castShadow = true;
      lootGroup.add(boot);
      lootGroup.userData.type = 'speed';
      lootGroup.userData.value = 0.1;
    } else if (type === 'weapon') {
      const weaponTypes = ['axe', 'spear', 'hammer', 'katana'];
      const randomWeapon = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
      const weaponData = weapons[randomWeapon];

      if (randomWeapon === 'axe') {
        const axeHandle = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
        const handleMat = new THREE.MeshStandardMaterial({ color: 0x4a2c17, roughness: 0.8 });
        const handle = new THREE.Mesh(axeHandle, handleMat);
        lootGroup.add(handle);

        const axeHead = new THREE.BoxGeometry(0.8, 0.6, 0.2);
        const headMat = new THREE.MeshStandardMaterial({
          color: weaponData.color,
          metalness: 0.8,
          roughness: 0.2
        });
        const head = new THREE.Mesh(axeHead, headMat);
        head.position.y = 0.7;
        lootGroup.add(head);
      } else if (randomWeapon === 'spear') {
        const spearShaft = new THREE.CylinderGeometry(0.08, 0.08, 2, 8);
        const shaftMat = new THREE.MeshStandardMaterial({ color: 0x4a2c17, roughness: 0.8 });
        const shaft = new THREE.Mesh(spearShaft, shaftMat);
        lootGroup.add(shaft);

        const spearTip = new THREE.ConeGeometry(0.2, 0.6, 4);
        const tipMat = new THREE.MeshStandardMaterial({
          color: weaponData.color,
          metalness: 0.9,
          roughness: 0.1
        });
        const tip = new THREE.Mesh(spearTip, tipMat);
        tip.position.y = 1.3;
        lootGroup.add(tip);
      } else if (randomWeapon === 'hammer') {
        const hammerHandle = new THREE.CylinderGeometry(0.1, 0.1, 1.8, 8);
        const handleMat = new THREE.MeshStandardMaterial({ color: 0x4a2c17, roughness: 0.8 });
        const handle = new THREE.Mesh(hammerHandle, handleMat);
        lootGroup.add(handle);

        const hammerHead = new THREE.BoxGeometry(0.6, 0.6, 0.6);
        const headMat = new THREE.MeshStandardMaterial({
          color: weaponData.color,
          metalness: 0.7,
          roughness: 0.3
        });
        const head = new THREE.Mesh(hammerHead, headMat);
        head.position.y = 0.9;
        lootGroup.add(head);
      } else if (randomWeapon === 'katana') {
        const katanaBlade = new THREE.BoxGeometry(0.15, 2.5, 0.4);
        const bladeMat = new THREE.MeshStandardMaterial({
          color: weaponData.color,
          metalness: 0.95,
          roughness: 0.05
        });
        const blade = new THREE.Mesh(katanaBlade, bladeMat);
        blade.position.y = 0.5;
        lootGroup.add(blade);

        const katanaHandle = new THREE.CylinderGeometry(0.12, 0.12, 0.8, 8);
        const handleMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.9 });
        const handle = new THREE.Mesh(katanaHandle, handleMat);
        handle.position.y = -0.9;
        lootGroup.add(handle);
      }

      lootGroup.userData.type = 'weapon';
      lootGroup.userData.weaponType = randomWeapon;
      lootGroup.userData.weaponData = weaponData;
    }

    lootGroup.position.copy(position);
    lootGroup.position.y = 1;
    lootGroup.userData.floatTime = Math.random() * Math.PI * 2;
    lootGroup.userData.rotationSpeed = 0.05;

    // Aura lumineuse am√©lior√©e
    const light = new THREE.PointLight(lootGroup.children[0].material.color, 1, 8);
    light.position.y = 0.5;
    lootGroup.add(light);

    return lootGroup;
  }

  function spawnWave() {
    const announcement = document.getElementById('waveAnnouncement');
    document.getElementById('waveText').textContent = currentWave;
    announcement.style.display = 'block';
    setTimeout(() => {
      announcement.style.display = 'none';
    }, 2000);

    for (let i = 0; i < zombiesPerWave; i++) {
      const angle = (Math.PI * 2 / zombiesPerWave) * i;
      const distance = 40 + Math.random() * 20;
      const x = Math.cos(angle) * distance;
      const z = Math.sin(angle) * distance;
      const zombie = createZombie(x, z);
      zombies.push(zombie);
      scene.add(zombie);
    }

    document.getElementById('waveNumber').textContent = currentWave;
    document.getElementById('remainingZombies').textContent = zombiesPerWave;
  }

  setTimeout(() => spawnWave(), 1000);

  // Arbres morts am√©lior√©s
  function createDeadTree(x, z) {
    const group = new THREE.Group();

    const trunkGeometry = new THREE.CylinderGeometry(0.8, 1.2, 12, 8);
    const trunkMaterial = new THREE.MeshStandardMaterial({
      color: 0x2a2a2a,
      roughness: 0.9,
      metalness: 0.1
    });
    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
    trunk.position.y = 6;
    trunk.castShadow = true;
    group.add(trunk);

    // Branches mortes
    for(let i = 0; i < 3; i++) {
      const branchGeometry = new THREE.CylinderGeometry(0.2, 0.3, 4, 6);
      const branch = new THREE.Mesh(branchGeometry, trunkMaterial);
      branch.position.set(
              Math.random() * 2 - 1,
              8 + Math.random() * 2,
              Math.random() * 2 - 1
      );
      branch.rotation.z = (Math.random() - 0.5) * Math.PI / 3;
      branch.castShadow = true;
      group.add(branch);
    }

    group.position.set(x, 0, z);
    return group;
  }

  for (let i = 0; i < 8; i++) {
    const x = Math.random() * 100 - 50;
    const z = Math.random() * 50 + 20;
    scene.add(createDeadTree(x, z));
  }

  // Rochers am√©lior√©s
  function createRock(x, z) {
    const rockGeometry = new THREE.DodecahedronGeometry(Math.random() * 3 + 1, 1);
    const rockMaterial = new THREE.MeshStandardMaterial({
      color: 0x444444,
      roughness: 0.9,
      metalness: 0.1
    });
    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
    rock.position.set(x, Math.random() * 1, z);
    rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
    rock.castShadow = true;
    rock.receiveShadow = true;
    return rock;
  }

  for (let i = 0; i < 20; i++) {
    const x = Math.random() * 200 - 100;
    const z = Math.random() * 100 - 50;
    scene.add(createRock(x, z));
  }

  // Variables de contr√¥le
  const keys = {};
  let cameraAngle = 0;
  let cameraDistance = 20;
  let cameraHeight = 10;
  let playerVelocityY = 0;
  const gravity = -0.5;
  const jumpForce = 10;
  let isJumping = false;
  let isFirstPerson = false;
  let walkAnimation = 0;
  let playerRotation = 0;

  // Contr√¥les
  document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;

    if (e.key === ' ' && !isJumping) {
      playerVelocityY = jumpForce;
      isJumping = true;
    }

    if (e.key.toLowerCase() === 'c') {
      isFirstPerson = !isFirstPerson;
      cameraDistance = isFirstPerson ? 0 : 20;
      cameraHeight = isFirstPerson ? 5 : 10;
    }

    if (e.key.toLowerCase() === 'f' && !isFishing && playerGroup.position.z < -20) {
      isFishing = true;
      fishingTimer = 0;
    }

    if (e.key.toLowerCase() === 'e') {
      lootItems.forEach((loot, index) => {
        const distance = playerGroup.position.distanceTo(loot.position);
        if (distance < 4) {
          switch(loot.userData.type) {
            case 'coin':
              coins += loot.userData.value;
              document.getElementById('coins').textContent = coins;
              break;
            case 'health':
              playerHealth = Math.min(100, playerHealth + loot.userData.value);
              document.getElementById('healthFill').style.width = playerHealth + '%';
              createHealEffect(playerGroup.position.clone());
              break;
            case 'attack':
              attackPower += loot.userData.value;
              document.getElementById('attackPower').textContent = attackPower;
              swordGroup.children[0].material.emissive = new THREE.Color(0xffff00);
              swordGroup.children[0].material.emissiveIntensity = 0.8;
              setTimeout(() => {
                swordGroup.children[0].material.emissiveIntensity = 0.2;
              }, 500);
              break;
            case 'armor':
              armor += loot.userData.value;
              document.getElementById('armor').textContent = armor;
              playerGroup.children[0].material.emissive = new THREE.Color(0x0000ff);
              playerGroup.children[0].material.emissiveIntensity = 0.5;
              setTimeout(() => {
                playerGroup.children[0].material.emissiveIntensity = 0;
              }, 500);
              break;
            case 'speed':
              speedBonus += loot.userData.value;
              document.getElementById('speedBonus').textContent = 'x' + speedBonus.toFixed(1);
              break;
            case 'weapon':
              currentWeapon = loot.userData.weaponType;
              const weaponData = loot.userData.weaponData;
              attackPower = weaponData.damage;
              weaponRange = weaponData.range;
              attackSpeed = weaponData.speed;

              const weaponNames = {
                'sword': '√âp√©e',
                'axe': 'Hache',
                'spear': 'Lance',
                'hammer': 'Marteau',
                'katana': 'Katana'
              };
              document.getElementById('currentWeapon').textContent = weaponNames[currentWeapon];
              document.getElementById('attackPower').textContent = attackPower;

              while(swordGroup.children.length > 0) {
                swordGroup.remove(swordGroup.children[0]);
              }

              if (currentWeapon === 'axe') {
                const axeHandle = new THREE.CylinderGeometry(0.1, 0.15, 3, 8);
                const handle = new THREE.Mesh(axeHandle, new THREE.MeshStandardMaterial({ color: 0x4a2c17, roughness: 0.8 }));
                handle.position.y = 1.5;
                swordGroup.add(handle);
                const axeHead = new THREE.BoxGeometry(1.2, 1, 0.3);
                const head = new THREE.Mesh(axeHead, new THREE.MeshStandardMaterial({
                  color: weaponData.color,
                  metalness: 0.8,
                  roughness: 0.2
                }));
                head.position.y = 3;
                swordGroup.add(head);
              } else if (currentWeapon === 'spear') {
                const spearShaft = new THREE.CylinderGeometry(0.1, 0.1, 5, 8);
                const shaft = new THREE.Mesh(spearShaft, new THREE.MeshStandardMaterial({ color: 0x4a2c17, roughness: 0.8 }));
                shaft.position.y = 2.5;
                swordGroup.add(shaft);
                const spearTip = new THREE.ConeGeometry(0.3, 0.8, 4);
                const tip = new THREE.Mesh(spearTip, new THREE.MeshStandardMaterial({
                  color: weaponData.color,
                  metalness: 0.9,
                  roughness: 0.1
                }));
                tip.position.y = 5.4;
                swordGroup.add(tip);
              } else if (currentWeapon === 'hammer') {
                const hammerHandle = new THREE.CylinderGeometry(0.12, 0.12, 3.5, 8);
                const handle = new THREE.Mesh(hammerHandle, new THREE.MeshStandardMaterial({ color: 0x4a2c17, roughness: 0.8 }));
                handle.position.y = 1.8;
                swordGroup.add(handle);
                const hammerHead = new THREE.BoxGeometry(1, 1, 1);
                const head = new THREE.Mesh(hammerHead, new THREE.MeshStandardMaterial({
                  color: weaponData.color,
                  metalness: 0.7,
                  roughness: 0.3
                }));
                head.position.y = 3.8;
                swordGroup.add(head);
              } else if (currentWeapon === 'katana') {
                const katanaBlade = new THREE.BoxGeometry(0.2, 5, 0.6);
                const blade = new THREE.Mesh(katanaBlade, new THREE.MeshStandardMaterial({
                  color: weaponData.color,
                  metalness: 0.95,
                  roughness: 0.05,
                  emissive: 0x4B0082,
                  emissiveIntensity: 0.2
                }));
                blade.position.y = 2.5;
                swordGroup.add(blade);
                const katanaHandle = new THREE.CylinderGeometry(0.15, 0.15, 1.2, 8);
                const handle = new THREE.Mesh(katanaHandle, new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.9 }));
                handle.position.y = -0.4;
                swordGroup.add(handle);
              } else {
                const bladeGeometry = new THREE.BoxGeometry(0.2, 4, 0.5);
                const blade = new THREE.Mesh(bladeGeometry, new THREE.MeshPhongMaterial({
                  color: 0xaaccff,
                  shininess: 200,
                  specular: 0xffffff,
                  emissive: 0x0066ff,
                  emissiveIntensity: 0.2
                }));
                blade.position.y = 2;
                swordGroup.add(blade);
                const guardGeometry = new THREE.BoxGeometry(1.5, 0.2, 0.3);
                const guard = new THREE.Mesh(guardGeometry, new THREE.MeshStandardMaterial({
                  color: 0xffdd00,
                  metalness: 0.9,
                  roughness: 0.2
                }));
                swordGroup.add(guard);
                const handleGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1, 8);
                const handle = new THREE.Mesh(handleGeometry, new THREE.MeshStandardMaterial({
                  color: 0x4a2c17,
                  roughness: 0.8
                }));
                handle.position.y = -0.8;
                swordGroup.add(handle);
              }

              swordGroup.children[0].material.emissive = new THREE.Color(0xffffff);
              swordGroup.children[0].material.emissiveIntensity = 1;
              setTimeout(() => {
                swordGroup.children[0].material.emissiveIntensity = currentWeapon === 'katana' ? 0.2 : 0;
              }, 500);
              break;
          }

          scene.remove(loot);
          lootItems.splice(index, 1);
        }
      });
    }
  });

  document.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
  });

  document.addEventListener('click', () => {
    if (attackCooldown <= 0 && !isFishing) {
      isAttacking = true;
      attackCooldown = attackSpeed;

      playerGroup.children[5].rotation.x = -Math.PI / 2;

      zombies.forEach((zombie, index) => {
        if (!zombie.userData.isDead) {
          const distance = playerGroup.position.distanceTo(zombie.position);
          if (distance < weaponRange) {
            const toZombie = new THREE.Vector3();
            toZombie.subVectors(zombie.position, playerGroup.position);
            toZombie.normalize();

            const playerDir = new THREE.Vector3(
                    Math.sin(playerRotation),
                    0,
                    Math.cos(playerRotation)
            );

            const dot = playerDir.dot(toZombie);
            if (dot > 0.5) {
              const isCritical = Math.random() < 0.2;
              const finalDamage = isCritical ? attackPower * 2 : attackPower;
              zombie.userData.health -= finalDamage;

              createBloodEffect(zombie.position.clone());
              if (isCritical) {
                createSparkEffect(zombie.position.clone(), 0xff0000);
                createShockwave(zombie.position.clone(), 3);
              }

              if (currentWeapon === 'hammer' && isCritical) {
                createShockwave(zombie.position.clone(), 8);
                zombie.position.x += toZombie.x * 5;
                zombie.position.z += toZombie.z * 5;
              } else if (currentWeapon === 'katana') {
                createSparkEffect(zombie.position.clone(), 0x9400D3);
              } else if (currentWeapon === 'axe') {
                createFireEffect(zombie.position.clone());
              }

              zombie.position.x += toZombie.x * 2;
              zombie.position.z += toZombie.z * 2;

              zombie.children[0].material.emissive = new THREE.Color(0xff0000);
              zombie.children[0].material.emissiveIntensity = 0.8;
              setTimeout(() => {
                zombie.children[0].material.emissiveIntensity = 0.1;
              }, 200);

              if (zombie.userData.health <= 0) {
                zombie.userData.isDead = true;
                killCount++;
                document.getElementById('killCount').textContent = killCount;

                createBloodEffect(zombie.position.clone());
                createSparkEffect(zombie.position.clone(), 0xff0000);
                createShockwave(zombie.position.clone(), 5);

                renderer.domElement.style.filter = 'brightness(1.8) saturate(1.5)';
                setTimeout(() => {
                  renderer.domElement.style.filter = 'contrast(1.1) saturate(1.2)';
                }, 100);

                const lootPosition = zombie.position.clone();

                const coinLoot = createLootItem(lootPosition.clone(), 'coin');
                lootItems.push(coinLoot);
                scene.add(coinLoot);

                const randomLoot = Math.random();
                if (randomLoot < 0.25) {
                  const healthLoot = createLootItem(
                          new THREE.Vector3(lootPosition.x + 1, lootPosition.y, lootPosition.z),
                          'health'
                  );
                  lootItems.push(healthLoot);
                  scene.add(healthLoot);
                } else if (randomLoot < 0.4) {
                  const weaponLoot = createLootItem(
                          new THREE.Vector3(lootPosition.x - 1, lootPosition.y, lootPosition.z + 1),
                          'weapon'
                  );
                  lootItems.push(weaponLoot);
                  scene.add(weaponLoot);
                } else if (randomLoot < 0.55) {
                  const attackLoot = createLootItem(
                          new THREE.Vector3(lootPosition.x - 1, lootPosition.y, lootPosition.z),
                          'attack'
                  );
                  lootItems.push(attackLoot);
                  scene.add(attackLoot);
                } else if (randomLoot < 0.65) {
                  const armorLoot = createLootItem(
                          new THREE.Vector3(lootPosition.x, lootPosition.y, lootPosition.z + 1),
                          'armor'
                  );
                  lootItems.push(armorLoot);
                  scene.add(armorLoot);
                } else if (randomLoot < 0.75) {
                  // Suite du code - √† ins√©rer apr√®s la ligne 1016 du fichier HTML principal

                  const speedLoot = createLootItem(
                          new THREE.Vector3(lootPosition.x, lootPosition.y, lootPosition.z - 1),
                          'speed'
                  );
                  lootItems.push(speedLoot);
                  scene.add(speedLoot);
                }

                let deathAnimation = 0;
                const deathInterval = setInterval(() => {
                  deathAnimation += 0.1;
                  zombie.rotation.x = deathAnimation;
                  zombie.position.y -= 0.1;
                  if (deathAnimation > Math.PI / 2) {
                    clearInterval(deathInterval);
                    scene.remove(zombie);
                    zombies.splice(index, 1);

                    const remaining = zombies.filter(z => !z.userData.isDead).length;
                    document.getElementById('remainingZombies').textContent = remaining;

                    if (remaining === 0) {
                      currentWave++;
                      zombiesPerWave += 2;
                      setTimeout(() => spawnWave(), 3000);
                    }
                  }
                }, 50);
              }
            }
          }
        }
      });
    }
  });

  document.addEventListener('mousemove', (e) => {
    cameraAngle -= e.movementX * 0.005;
  });

  document.addEventListener('wheel', (e) => {
    if (!isFirstPerson) {
      cameraDistance += e.deltaY * 0.01;
      cameraDistance = Math.max(10, Math.min(50, cameraDistance));
    }
  });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Variables pour l'animation
  let waterTime = 0;
  let time = 0;

  // Post-processing simple pour effet cin√©matique
  const composer = {
    render: function() {
      renderer.render(scene, camera);
    }
  };

  // Animation principale am√©lior√©e
  function animate() {
    requestAnimationFrame(animate);
    time += 0.016;

    // Animation des √©toiles
    stars.rotation.y += 0.0001;

    // Pulsation de la lumi√®re rouge
    redLight.intensity = 0.3 + Math.sin(time * 2) * 0.1;

    // Animation de la lumi√®re du joueur
    if (playerLight) {
      playerLight.intensity = 0.5 + Math.sin(time * 4) * 0.1;
    }

    // Gestion de la p√™che/soin
    if (isFishing) {
      fishingTimer += 0.016;
      if (Math.random() < 0.15) {
        const waterParticle = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 6, 6),
                new THREE.MeshPhongMaterial({
                  color: 0x00ccff,
                  transparent: true,
                  opacity: 0.8,
                  emissive: 0x00ccff,
                  emissiveIntensity: 0.5
                })
        );
        waterParticle.position.set(
                playerGroup.position.x + (Math.random() - 0.5) * 3,
                Math.random() * 2,
                playerGroup.position.z - 2
        );
        scene.add(waterParticle);
        setTimeout(() => scene.remove(waterParticle), 1500);
      }

      if (fishingTimer > 2) {
        isFishing = false;
        playerHealth = Math.min(100, playerHealth + 10);
        document.getElementById('healthFill').style.width = playerHealth + '%';
        createHealEffect(playerGroup.position.clone());
        createSparkEffect(playerGroup.position.clone(), 0x00ff00);
      }
    }

    // Cooldown d'attaque
    if (attackCooldown > 0) {
      attackCooldown -= 0.016;
      if (attackCooldown <= 0.3 && isAttacking) {
        playerGroup.children[5].rotation.x = 0;
        isAttacking = false;
      }
    }

    // IA des zombies am√©lior√©e
    zombies.forEach(zombie => {
      if (!zombie.userData.isDead) {
        const direction = new THREE.Vector3();
        direction.subVectors(playerGroup.position, zombie.position);
        direction.y = 0;
        const distance = direction.length();
        direction.normalize();

        if (distance > 2) {
          zombie.position.x += direction.x * zombie.userData.speed;
          zombie.position.z += direction.z * zombie.userData.speed;

          zombie.lookAt(playerGroup.position);

          // Animation de marche plus fluide
          zombie.userData.walkAnimation += 0.15;
          const walkCycle = Math.sin(zombie.userData.walkAnimation);
          zombie.children[5].rotation.x = walkCycle * 0.6;
          zombie.children[6].rotation.x = -walkCycle * 0.6;
          zombie.children[3].rotation.x = -Math.PI / 6 + walkCycle * 0.3;
          zombie.children[4].rotation.x = -Math.PI / 6 - walkCycle * 0.3;

          // Balancement du corps
          zombie.rotation.z = Math.sin(zombie.userData.walkAnimation * 2) * 0.05;
        }

        // Attaque du zombie
        if (distance < 3 && zombie.userData.attackCooldown <= 0) {
          const damage = Math.max(1, 5 - armor);
          playerHealth -= damage;
          zombie.userData.attackCooldown = 1.5;
          document.getElementById('healthFill').style.width = playerHealth + '%';

          createBloodEffect(playerGroup.position.clone());
          createSparkEffect(playerGroup.position.clone(), 0xff0000);

          // Effet de d√©g√¢t am√©lior√©
          renderer.domElement.style.filter = 'brightness(2) saturate(3) hue-rotate(-20deg) contrast(1.5)';
          renderer.domElement.style.transform = `translate(${Math.random() * 15 - 7.5}px, ${Math.random() * 15 - 7.5}px) rotate(${Math.random() * 2 - 1}deg)`;
          setTimeout(() => {
            renderer.domElement.style.filter = 'contrast(1.1) saturate(1.2)';
            renderer.domElement.style.transform = 'none';
          }, 150);

          if (playerHealth <= 0) {
            alert(`Game Over! Vous avez tu√© ${killCount} zombies et atteint la vague ${currentWave}`);
            location.reload();
          }
        }

        if (zombie.userData.attackCooldown > 0) {
          zombie.userData.attackCooldown -= 0.016;
        }

        // Lueur des yeux
        if (zombie.children[2] && zombie.children[3]) {
          const eyeGlow = 0.5 + Math.sin(time * 5 + zombie.userData.walkAnimation) * 0.5;
          zombie.children[2].material.emissiveIntensity = eyeGlow;
          zombie.children[3].material.emissiveIntensity = eyeGlow;
        }
      }
    });

    // Animation des particules de sang am√©lior√©e
    bloodParticles.forEach((particle, index) => {
      particle.userData.velocity.y -= 0.03;
      particle.position.add(particle.userData.velocity);
      particle.userData.life -= 0.025;
      particle.material.opacity = particle.userData.life;
      particle.scale.setScalar(particle.userData.life);
      particle.rotation.x += 0.1;
      particle.rotation.y += 0.1;

      if (particle.userData.life <= 0) {
        scene.remove(particle);
        bloodParticles.splice(index, 1);
      }
    });

    // Animation des √©tincelles am√©lior√©e
    sparkParticles.forEach((particle, index) => {
      particle.userData.velocity.y -= 0.04;
      particle.position.add(particle.userData.velocity);
      particle.rotation.x += particle.userData.rotationSpeed;
      particle.rotation.y += particle.userData.rotationSpeed;
      particle.rotation.z += particle.userData.rotationSpeed * 0.5;
      particle.userData.life -= 0.035;
      particle.material.opacity = particle.userData.life;
      particle.material.emissiveIntensity = particle.userData.life;

      if (particle.userData.life <= 0) {
        scene.remove(particle);
        sparkParticles.splice(index, 1);
      }
    });

    // Animation des particules de soin am√©lior√©e
    healParticles.forEach((particle, index) => {
      particle.position.add(particle.userData.velocity);
      particle.rotation.x += 0.15;
      particle.rotation.y += 0.15;
      particle.rotation.z += 0.05;
      particle.userData.life -= 0.02;
      particle.material.opacity = particle.userData.life;
      particle.material.emissiveIntensity = particle.userData.life * 0.8;
      particle.scale.setScalar(particle.userData.life * 1.5);

      // Mouvement en spirale
      particle.position.x += Math.sin(time * 10 + index) * 0.02;
      particle.position.z += Math.cos(time * 10 + index) * 0.02;

      if (particle.userData.life <= 0) {
        scene.remove(particle);
        healParticles.splice(index, 1);
      }
    });

    // Animation des particules de feu am√©lior√©e
    fireParticles.forEach((particle, index) => {
      particle.position.add(particle.userData.velocity);
      particle.userData.velocity.y += 0.01; // Feu monte
      particle.userData.life -= 0.04;
      particle.material.opacity = particle.userData.life;
      particle.material.emissiveIntensity = particle.userData.life;
      particle.scale.setScalar(particle.userData.life * 2.5);
      particle.rotation.x += 0.2;
      particle.rotation.y += 0.2;

      // Changement de couleur
      const hue = particle.userData.life;
      particle.material.color.setHSL(0.1 * hue, 1, 0.5);

      if (particle.userData.life <= 0) {
        scene.remove(particle);
        fireParticles.splice(index, 1);
      }
    });

    // Animation de la tra√Æn√©e d'arme am√©lior√©e
    if (isAttacking) {
      const swordWorldPos = new THREE.Vector3();
      playerGroup.children[5].getWorldPosition(swordWorldPos);
      createWeaponTrail(swordWorldPos);
    }

    weaponTrail.forEach((trail, index) => {
      trail.userData.life -= 0.08;
      trail.material.opacity = trail.userData.life;
      trail.scale.y = trail.userData.life;

      if (trail.userData.life <= 0) {
        scene.remove(trail);
        weaponTrail.splice(index, 1);
      }
    });

    // Mouvement du joueur am√©lior√©
    if (!isFishing) {
      const baseSpeed = keys['shift'] ? 0.8 : 0.4;
      const speed = baseSpeed * speedBonus;
      let moved = false;
      let moveX = 0;
      let moveZ = 0;

      if (keys['z'] || keys['arrowup']) {
        moveZ -= speed;
        moved = true;
      }
      if (keys['s'] || keys['arrowdown']) {
        moveZ += speed;
        moved = true;
      }
      if (keys['q'] || keys['arrowleft']) {
        moveX -= speed;
        moved = true;
      }
      if (keys['d'] || keys['arrowright']) {
        moveX += speed;
        moved = true;
      }

      if (moved) {
        const moveAngle = Math.atan2(moveX, moveZ);
        const finalAngle = cameraAngle + moveAngle;

        playerGroup.position.x += Math.sin(finalAngle) * speed;
        playerGroup.position.z += Math.cos(finalAngle) * speed;

        playerRotation = finalAngle;
        playerGroup.rotation.y = playerRotation;

        // Animation de marche am√©lior√©e
        if (!isAttacking) {
          walkAnimation += speed * 0.5;
          const walkCycle = Math.sin(walkAnimation);
          playerGroup.children[6].rotation.x = walkCycle * 0.6;
          playerGroup.children[7].rotation.x = -walkCycle * 0.6;
          playerGroup.children[4].rotation.x = -walkCycle * 0.4;

          // Balancement des bras
          if (!isAttacking) {
            playerGroup.children[4].rotation.z = walkCycle * 0.1;
            playerGroup.children[5].rotation.z = -Math.PI / 6 - walkCycle * 0.1;
          }
        }
      } else {
        if (!isAttacking) {
          playerGroup.children[6].rotation.x = 0;
          playerGroup.children[7].rotation.x = 0;
          playerGroup.children[4].rotation.x = 0;
          playerGroup.children[4].rotation.z = 0;
          playerGroup.children[5].rotation.z = -Math.PI / 6;
        }
      }
    }

    // Physique du saut am√©lior√©e
    if (isJumping) {
      playerVelocityY += gravity;
      playerGroup.position.y += playerVelocityY * 0.1;

      if (playerGroup.position.y <= 0.5) {
        playerGroup.position.y = 0.5;
        playerVelocityY = 0;
        isJumping = false;

        // Particules d'atterrissage
        for(let i = 0; i < 5; i++) {
          const dustGeometry = new THREE.SphereGeometry(0.2, 4, 4);
          const dustMaterial = new THREE.MeshBasicMaterial({
            color: 0x8b7355,
            transparent: true,
            opacity: 0.5
          });
          const dust = new THREE.Mesh(dustGeometry, dustMaterial);
          dust.position.copy(playerGroup.position);
          dust.position.y = 0;
          scene.add(dust);
          setTimeout(() => scene.remove(dust), 500);
        }
      }
    }

    // Animation des objets de loot am√©lior√©e
    lootItems.forEach(loot => {
      loot.userData.floatTime += 0.05;
      loot.position.y = 1 + Math.sin(loot.userData.floatTime) * 0.4;
      loot.rotation.y += loot.userData.rotationSpeed;

      // Pulsation lumineuse
      if (loot.children[1]) {
        loot.children[1].intensity = 1 + Math.sin(loot.userData.floatTime * 2) * 0.5;
      }

      // Particules brillantes occasionnelles
      if (Math.random() < 0.02) {
        const sparkle = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 4, 4),
                new THREE.MeshBasicMaterial({
                  color: loot.children[0].material.color,
                  transparent: true,
                  opacity: 0.8
                })
        );
        sparkle.position.copy(loot.position);
        sparkle.position.x += (Math.random() - 0.5) * 2;
        sparkle.position.y += Math.random() * 2;
        sparkle.position.z += (Math.random() - 0.5) * 2;
        scene.add(sparkle);
        setTimeout(() => scene.remove(sparkle), 1000);
      }
    });

    // Position de la cam√©ra am√©lior√©e avec smoothing
    if (isFirstPerson) {
      camera.position.x = playerGroup.position.x;
      camera.position.y = playerGroup.position.y + 5;
      camera.position.z = playerGroup.position.z;
      camera.rotation.y = cameraAngle;
    } else {
      const targetX = playerGroup.position.x + Math.sin(cameraAngle) * cameraDistance;
      const targetZ = playerGroup.position.z + Math.cos(cameraAngle) * cameraDistance;

      camera.position.x += (targetX - camera.position.x) * 0.1;
      camera.position.y += (playerGroup.position.y + cameraHeight - camera.position.y) * 0.1;
      camera.position.z += (targetZ - camera.position.z) * 0.1;

      camera.lookAt(playerGroup.position.x, playerGroup.position.y + 3, playerGroup.position.z);
    }

    // Animation de l'oc√©an am√©lior√©e
    waterTime += 0.015;
    const oceanVertices = ocean.geometry.attributes.position.array;
    for (let i = 0; i < oceanVertices.length; i += 3) {
      const x = oceanVertices[i];
      const y = oceanVertices[i + 1];
      oceanVertices[i + 2] =
              Math.sin((x * 0.05) + waterTime) * 2 +
              Math.cos((y * 0.05) + waterTime * 0.7) * 1.5 +
              Math.sin((x * 0.02) + waterTime * 1.3) * 0.8;
    }
    ocean.geometry.attributes.position.needsUpdate = true;
    ocean.geometry.computeVertexNormals();

    // Rendu avec effets
    composer.render();
  }

  animate();
</script>
</body>
</html>