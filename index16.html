<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Defender - Jeu de Tir</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a0033 100%);
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }

        .game-container {
            position: relative;
            box-shadow: 0 0 50px rgba(138, 43, 226, 0.5);
            border: 2px solid #8a2be2;
            border-radius: 10px;
        }

        canvas {
            display: block;
            background: #000;
            cursor: none;
        }

        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            color: #0ff;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #0ff;
            pointer-events: none;
        }

        .game-over, .start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #fff;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #8a2be2;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.8);
        }

        .game-over h2, .start-screen h2 {
            font-size: 48px;
            color: #ff0080;
            text-shadow: 0 0 20px #ff0080;
            margin-bottom: 20px;
        }

        .score-display {
            font-size: 24px;
            color: #0ff;
            margin: 15px 0;
        }

        button {
            padding: 15px 30px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(135deg, #8a2be2, #ff0080);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
        }

        button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 25px rgba(138, 43, 226, 0.6);
        }

        .controls {
            margin-top: 20px;
            color: #aaa;
            font-size: 14px;
        }

        .powerup-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #ffff00;
            font-size: 16px;
            text-shadow: 0 0 10px #ffff00;
        }
    </style>
</head>
<body>
<div class="game-container">
    <canvas id="gameCanvas"></canvas>

    <div class="hud">
        <div>Score: <span id="score">0</span></div>
        <div>Niveau: <span id="level">1</span></div>
        <div>Vies: <span id="lives">3</span></div>
    </div>

    <div class="powerup-indicator" id="powerupIndicator"></div>

    <div class="start-screen" id="startScreen">
        <h2>SPACE DEFENDER</h2>
        <button onclick="startGame()">COMMENCER</button>
        <div class="controls">
            <p>‚Üë‚Üì‚Üê‚Üí Fl√®ches ou WASD pour bouger</p>
            <p>ESPACE pour tirer (maintenir)</p>
            <p>SHIFT pour tir sp√©cial</p>
        </div>
    </div>

    <div class="game-over" id="gameOver" style="display: none;">
        <h2>GAME OVER</h2>
        <div class="score-display">Score Final: <span id="finalScore">0</span></div>
        <div class="score-display">Meilleur Score: <span id="highScore">0</span></div>
        <button onclick="restartGame()">REJOUER</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    canvas.width = 800;
    canvas.height = 600;

    let gameState = 'start';
    let score = 0;
    let level = 1;
    let lives = 3;
    let highScore = localStorage.getItem('spaceDefenderHighScore') || 0;
    let mouseX = canvas.width / 2;
    let mouseY = canvas.height - 100;

    // Joueur
    const player = {
        x: canvas.width / 2,
        y: canvas.height - 80,
        width: 60,
        height: 60,
        speed: 7,
        powerup: null,
        powerupTime: 0,
        specialAmmo: 3,
        lastShot: 0
    };

    // Arrays pour les objets du jeu
    let bullets = [];
    let enemies = [];
    let enemyBullets = [];
    let particles = [];
    let powerups = [];
    let stars = [];

    // Touches press√©es
    const keys = {};

    // Types d'ennemis
    const enemyTypes = {
        basic: { width: 40, height: 40, speed: 2, health: 1, points: 10, color: '#ff0080' },
        fast: { width: 30, height: 30, speed: 4, health: 1, points: 20, color: '#00ff80' },
        tank: { width: 50, height: 50, speed: 1, health: 3, points: 50, color: '#ff8000' },
        shooter: { width: 45, height: 45, speed: 1.5, health: 2, points: 30, color: '#8080ff' }
    };

    // Types de power-ups
    const powerupTypes = {
        tripleShot: { color: '#00ffff', duration: 5000, symbol: '‚ö°' },
        rapidFire: { color: '#ffff00', duration: 5000, symbol: 'üî•' },
        shield: { color: '#00ff00', duration: 8000, symbol: 'üõ°Ô∏è' },
        bomb: { color: '#ff00ff', instant: true, symbol: 'üí£' }
    };

    // Initialiser les √©toiles de fond
    function initStars() {
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2,
                speed: Math.random() * 1 + 0.5
            });
        }
    }

    // Cr√©er une particule
    function createParticle(x, y, color) {
        for (let i = 0; i < 10; i++) {
            particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                size: Math.random() * 3 + 1,
                life: 1,
                color: color
            });
        }
    }

    // Cr√©er une explosion
    function createExplosion(x, y) {
        for (let i = 0; i < 20; i++) {
            const angle = (Math.PI * 2 * i) / 20;
            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * (Math.random() * 4 + 2),
                vy: Math.sin(angle) * (Math.random() * 4 + 2),
                size: Math.random() * 5 + 2,
                life: 1,
                color: `hsl(${Math.random() * 60}, 100%, 50%)`
            });
        }
    }

    // Spawner des ennemis
    function spawnEnemy() {
        const types = Object.keys(enemyTypes);
        let availableTypes = types.slice(0, Math.min(Math.floor(level / 2) + 1, types.length));
        const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
        const enemyData = enemyTypes[type];

        enemies.push({
            x: Math.random() * (canvas.width - enemyData.width),
            y: -enemyData.height,
            ...enemyData,
            type: type,
            currentHealth: enemyData.health,
            shootTimer: 0
        });
    }

    // Tirer
    function shoot() {
        const bulletSpeed = 10;

        if (player.powerup === 'tripleShot') {
            for (let i = -1; i <= 1; i++) {
                bullets.push({
                    x: player.x + player.width / 2,
                    y: player.y,
                    vx: i * 2,
                    vy: -bulletSpeed,
                    width: 4,
                    height: 12,
                    damage: 1
                });
            }
        } else {
            bullets.push({
                x: player.x + player.width / 2,
                y: player.y,
                vx: 0,
                vy: -bulletSpeed,
                width: 4,
                height: 12,
                damage: 1
            });
        }

        createParticle(player.x + player.width / 2, player.y, '#00ffff');
    }

    // Tir sp√©cial
    function specialShoot() {
        if (player.specialAmmo > 0) {
            player.specialAmmo--;

            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                bullets.push({
                    x: player.x + player.width / 2,
                    y: player.y + player.height / 2,
                    vx: Math.cos(angle) * 8,
                    vy: Math.sin(angle) * 8,
                    width: 8,
                    height: 8,
                    damage: 2,
                    special: true
                });
            }

            createExplosion(player.x + player.width / 2, player.y + player.height / 2);
        }
    }

    // Mise √† jour du jeu
    function update() {
        if (gameState !== 'playing') return;

        // D√©placer les √©toiles
        stars.forEach(star => {
            star.y += star.speed;
            if (star.y > canvas.height) {
                star.y = 0;
                star.x = Math.random() * canvas.width;
            }
        });

        // D√©placer le joueur avec les fl√®ches
        if (keys['ArrowLeft'] || keys['a'] || keys['A']) {
            player.x = Math.max(0, player.x - player.speed);
        }
        if (keys['ArrowRight'] || keys['d'] || keys['D']) {
            player.x = Math.min(canvas.width - player.width, player.x + player.speed);
        }
        if (keys['ArrowUp'] || keys['w'] || keys['W']) {
            player.y = Math.max(50, player.y - player.speed);
        }
        if (keys['ArrowDown'] || keys['s'] || keys['S']) {
            player.y = Math.min(canvas.height - player.height, player.y + player.speed);
        }

        // Tir automatique avec la barre d'espace maintenue
        if (keys[' '] && Date.now() - player.lastShot > (player.powerup === 'rapidFire' ? 100 : 200)) {
            shoot();
            player.lastShot = Date.now();
        }

        // G√©rer le power-up
        if (player.powerup && Date.now() - player.powerupTime > powerupTypes[player.powerup].duration) {
            player.powerup = null;
        }

        // Mise √† jour des balles
        bullets = bullets.filter(bullet => {
            bullet.x += bullet.vx;
            bullet.y += bullet.vy;
            return bullet.y > -20 && bullet.y < canvas.height + 20 &&
                bullet.x > -20 && bullet.x < canvas.width + 20;
        });

        // Mise √† jour des ennemis
        enemies.forEach((enemy, index) => {
            enemy.y += enemy.speed;

            // Pattern de mouvement pour certains types
            if (enemy.type === 'fast') {
                enemy.x += Math.sin(Date.now() * 0.01 + index) * 3;
            }

            // Tir ennemi
            if (enemy.type === 'shooter') {
                enemy.shootTimer++;
                if (enemy.shootTimer > 60) {
                    enemy.shootTimer = 0;
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    enemyBullets.push({
                        x: enemy.x + enemy.width / 2,
                        y: enemy.y + enemy.height,
                        vx: Math.cos(angle) * 4,
                        vy: Math.sin(angle) * 4,
                        width: 6,
                        height: 6
                    });
                }
            }
        });

        // Retirer les ennemis sortis de l'√©cran
        enemies = enemies.filter(enemy => {
            if (enemy.y > canvas.height) {
                lives--;
                updateHUD();
                if (lives <= 0) {
                    gameOver();
                }
                return false;
            }
            return true;
        });

        // Mise √† jour des balles ennemies
        enemyBullets = enemyBullets.filter(bullet => {
            bullet.x += bullet.vx;
            bullet.y += bullet.vy;
            return bullet.y < canvas.height + 20 && bullet.y > -20;
        });

        // Mise √† jour des particules
        particles = particles.filter(particle => {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.life -= 0.02;
            particle.vx *= 0.98;
            particle.vy *= 0.98;
            return particle.life > 0;
        });

        // Mise √† jour des power-ups
        powerups = powerups.filter(powerup => {
            powerup.y += 2;
            powerup.rotation += 0.05;
            return powerup.y < canvas.height + 50;
        });

        // Collisions balles-ennemis
        bullets.forEach((bullet, bulletIndex) => {
            enemies.forEach((enemy, enemyIndex) => {
                if (collision(bullet, enemy)) {
                    enemy.currentHealth -= bullet.damage;
                    createParticle(bullet.x, bullet.y, enemy.color);

                    if (enemy.currentHealth <= 0) {
                        score += enemy.points;
                        createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);

                        // Chance de drop de power-up
                        if (Math.random() < 0.1) {
                            const types = Object.keys(powerupTypes);
                            const type = types[Math.floor(Math.random() * types.length)];
                            powerups.push({
                                x: enemy.x + enemy.width / 2,
                                y: enemy.y + enemy.height / 2,
                                type: type,
                                width: 30,
                                height: 30,
                                rotation: 0
                            });
                        }

                        // Chance de r√©cup√©rer une munition sp√©ciale
                        if (Math.random() < 0.05) {
                            player.specialAmmo = Math.min(player.specialAmmo + 1, 5);
                        }

                        enemies.splice(enemyIndex, 1);
                    }

                    bullets.splice(bulletIndex, 1);
                }
            });
        });

        // Collisions joueur-ennemis
        enemies.forEach((enemy, index) => {
            if (collision(player, enemy)) {
                if (player.powerup !== 'shield') {
                    lives--;
                    createExplosion(player.x + player.width / 2, player.y + player.height / 2);
                    updateHUD();
                    if (lives <= 0) {
                        gameOver();
                    }
                }
                createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                enemies.splice(index, 1);
            }
        });

        // Collisions joueur-balles ennemies
        enemyBullets.forEach((bullet, index) => {
            if (collision(player, bullet)) {
                if (player.powerup !== 'shield') {
                    lives--;
                    updateHUD();
                    if (lives <= 0) {
                        gameOver();
                    }
                }
                createParticle(bullet.x, bullet.y, '#ff0000');
                enemyBullets.splice(index, 1);
            }
        });

        // Collisions joueur-powerups
        powerups.forEach((powerup, index) => {
            if (collision(player, powerup)) {
                if (powerupTypes[powerup.type].instant) {
                    // Power-up instantan√© (bombe)
                    enemies = [];
                    enemyBullets = [];
                    createExplosion(canvas.width / 2, canvas.height / 2);
                    score += 100;
                } else {
                    player.powerup = powerup.type;
                    player.powerupTime = Date.now();
                }
                powerups.splice(index, 1);
                updatePowerupIndicator();
            }
        });

        // Progression de niveau
        if (score > level * 500) {
            level++;
            player.specialAmmo = Math.min(player.specialAmmo + 2, 5);
            updateHUD();
        }

        // Spawn des ennemis
        const spawnRate = Math.max(30, 60 - level * 5);
        if (Math.random() < 1 / spawnRate) {
            spawnEnemy();
        }

        updateHUD();
    }

    // Fonction de collision
    function collision(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
            rect1.x + rect1.width > rect2.x &&
            rect1.y < rect2.y + rect2.height &&
            rect1.y + rect1.height > rect2.y;
    }

    // Dessiner le jeu
    function draw() {
        // Effacer le canvas
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Dessiner les √©toiles
        ctx.fillStyle = '#fff';
        stars.forEach(star => {
            ctx.globalAlpha = star.size / 2;
            ctx.fillRect(star.x, star.y, star.size, star.size);
        });
        ctx.globalAlpha = 1;

        // Dessiner les particules
        particles.forEach(particle => {
            ctx.globalAlpha = particle.life;
            ctx.fillStyle = particle.color;
            ctx.fillRect(particle.x - particle.size / 2, particle.y - particle.size / 2,
                particle.size, particle.size);
        });
        ctx.globalAlpha = 1;

        // Dessiner le joueur
        ctx.save();
        ctx.translate(player.x + player.width / 2, player.y + player.height / 2);

        // Bouclier si actif
        if (player.powerup === 'shield') {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
            ctx.beginPath();
            ctx.arc(0, 0, player.width / 2 + 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        // Vaisseau du joueur
        ctx.fillStyle = '#00ffff';
        ctx.beginPath();
        ctx.moveTo(0, -player.height / 2);
        ctx.lineTo(-player.width / 2, player.height / 2);
        ctx.lineTo(0, player.height / 3);
        ctx.lineTo(player.width / 2, player.height / 2);
        ctx.closePath();
        ctx.fill();

        // D√©tails du vaisseau
        ctx.fillStyle = '#0088ff';
        ctx.beginPath();
        ctx.moveTo(0, -player.height / 3);
        ctx.lineTo(-player.width / 4, player.height / 4);
        ctx.lineTo(0, 0);
        ctx.lineTo(player.width / 4, player.height / 4);
        ctx.closePath();
        ctx.fill();

        ctx.restore();

        // Dessiner les balles
        bullets.forEach(bullet => {
            if (bullet.special) {
                // Balles sp√©ciales
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.width, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                // Balles normales
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(bullet.x - bullet.width / 2, bullet.y - bullet.height / 2,
                    bullet.width, bullet.height);
            }
        });

        // Dessiner les ennemis
        enemies.forEach(enemy => {
            ctx.save();
            ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);

            // Forme de l'ennemi selon le type
            ctx.fillStyle = enemy.color;
            if (enemy.type === 'basic') {
                ctx.fillRect(-enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
            } else if (enemy.type === 'fast') {
                ctx.beginPath();
                ctx.moveTo(0, -enemy.height / 2);
                ctx.lineTo(-enemy.width / 2, enemy.height / 2);
                ctx.lineTo(enemy.width / 2, enemy.height / 2);
                ctx.closePath();
                ctx.fill();
            } else if (enemy.type === 'tank') {
                ctx.fillRect(-enemy.width / 2, -enemy.height / 2, enemy.width, enemy.height);
                ctx.fillStyle = '#ff4000';
                ctx.fillRect(-enemy.width / 3, -enemy.height / 3, enemy.width * 2/3, enemy.height * 2/3);
            } else if (enemy.type === 'shooter') {
                ctx.beginPath();
                ctx.arc(0, 0, enemy.width / 2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Barre de vie pour les ennemis avec plus d'1 PV
            if (enemy.health > 1) {
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-enemy.width / 2, -enemy.height / 2 - 10,
                    enemy.width * (enemy.currentHealth / enemy.health), 3);
            }

            ctx.restore();
        });

        // Dessiner les balles ennemies
        ctx.fillStyle = '#ff0080';
        enemyBullets.forEach(bullet => {
            ctx.beginPath();
            ctx.arc(bullet.x, bullet.y, bullet.width / 2, 0, Math.PI * 2);
            ctx.fill();
        });

        // Dessiner les power-ups
        powerups.forEach(powerup => {
            ctx.save();
            ctx.translate(powerup.x, powerup.y);
            ctx.rotate(powerup.rotation);

            // Fond du power-up
            ctx.fillStyle = powerupTypes[powerup.type].color;
            ctx.globalAlpha = 0.8;
            ctx.fillRect(-powerup.width / 2, -powerup.height / 2, powerup.width, powerup.height);

            // Symbole
            ctx.globalAlpha = 1;
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(powerupTypes[powerup.type].symbol, 0, 0);

            ctx.restore();
        });

        // Indicateur de munitions sp√©ciales
        if (player.specialAmmo > 0) {
            ctx.fillStyle = '#ffff00';
            ctx.font = '16px Courier New';
            ctx.fillText(`Tirs Sp√©ciaux: ${player.specialAmmo}`, 10, canvas.height - 40);
        }
    }

    // Mettre √† jour l'HUD
    function updateHUD() {
        document.getElementById('score').textContent = score;
        document.getElementById('level').textContent = level;
        document.getElementById('lives').textContent = lives;
    }

    // Mettre √† jour l'indicateur de power-up
    function updatePowerupIndicator() {
        const indicator = document.getElementById('powerupIndicator');
        if (player.powerup) {
            indicator.textContent = `Power-up: ${player.powerup}`;
        } else {
            indicator.textContent = '';
        }
    }

    // Game Over
    function gameOver() {
        gameState = 'gameOver';
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('spaceDefenderHighScore', highScore);
        }
        document.getElementById('finalScore').textContent = score;
        document.getElementById('highScore').textContent = highScore;
        document.getElementById('gameOver').style.display = 'block';
    }

    // D√©marrer le jeu
    function startGame() {
        document.getElementById('startScreen').style.display = 'none';
        gameState = 'playing';
        initStars();
        gameLoop();
    }

    // Red√©marrer le jeu
    function restartGame() {
        score = 0;
        level = 1;
        lives = 3;
        player.x = canvas.width / 2;
        player.y = canvas.height - 80;
        player.powerup = null;
        player.specialAmmo = 3;
        bullets = [];
        enemies = [];
        enemyBullets = [];
        particles = [];
        powerups = [];
        gameState = 'playing';
        document.getElementById('gameOver').style.display = 'none';
        updateHUD();
    }

    // Boucle de jeu
    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    // √âv√©nements
    document.addEventListener('keydown', (e) => {
        keys[e.key] = true;

        if (e.key === 'Shift' && gameState === 'playing') {
            e.preventDefault();
            specialShoot();
        }

        // Emp√™cher le d√©filement de la page avec les fl√®ches
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
            e.preventDefault();
        }
    });

    document.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });

    // Initialisation
    updateHUD();
</script>
</body>
</html>